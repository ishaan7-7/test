# Cell: summary of CSV row counts and date ranges (first 12 days, then 7-day blocks from day 13)
import math
from pathlib import Path
import pandas as pd

CSV_PATH = Path(r"C:\Users\ishaa\OneDrive\Desktop\synthetic_data_final\synthetic_engine_inference_scenarioA.csv")
if not CSV_PATH.exists():
    raise FileNotFoundError(f"CSV not found: {CSV_PATH}")

# Load only timestamp column (fast)
df_ts = pd.read_csv(CSV_PATH, usecols=["timestamp"], low_memory=False)
n_total = len(df_ts)
print(f"Total rows in CSV: {n_total:,}")

# Parse timestamps (UTC aware)
df_ts["timestamp"] = pd.to_datetime(df_ts["timestamp"], utc=True, errors="coerce")
if df_ts["timestamp"].isna().any():
    n_bad = int(df_ts["timestamp"].isna().sum())
    print(f"Warning: {n_bad} rows had unparsable timestamps and will be ignored for date calculations.")

# overall start / end (based on non-null timestamps)
valid = df_ts["timestamp"].dropna()
if valid.empty:
    raise ValueError("No valid timestamps found in CSV.")
start_ts = valid.min()
end_ts = valid.max()
print(f"Overall start timestamp: {start_ts} (UTC)")
print(f"Overall end   timestamp: {end_ts} (UTC)")

# Normalize start date (midnight) and build day index for each row
start_date = start_ts.normalize()  # Timestamp at 00:00 of first day
df_ts["date_only"] = df_ts["timestamp"].dt.date
df_ts["day_index"] = ((df_ts["timestamp"].dt.normalize() - start_date).dt.days).astype("Int64")

# Rows in first 12 days (day_index 0..11)
mask_first12 = (df_ts["day_index"].notna()) & (df_ts["day_index"] >= 0) & (df_ts["day_index"] <= 11)
rows_first12 = int(mask_first12.sum())
print(f"\nRows in first 12 days (day 0..11 starting {start_date.date()}): {rows_first12:,}")

# Now compute counts for contiguous 7-day blocks starting from day_index 12 (i.e., day 13)
# Determine max day index present
max_day_index = int(df_ts["day_index"].dropna().max())
if max_day_index < 12:
    print("\nNo rows beyond the first 12 days to form 7-day blocks.")
else:
    blocks = []
    block_start = 12
    block_id = 0
    while block_start <= max_day_index:
        block_end = block_start + 6  # inclusive
        mask_block = (df_ts["day_index"].notna()) & (df_ts["day_index"] >= block_start) & (df_ts["day_index"] <= block_end)
        cnt = int(mask_block.sum())
        start_day = (start_date + pd.Timedelta(days=block_start)).date()
        end_day = (start_date + pd.Timedelta(days=min(block_end, max_day_index))).date()
        blocks.append((block_id+1, block_start, min(block_end, max_day_index), start_day, end_day, cnt))
        block_id += 1
        block_start += 7

    print("\n7-day blocks starting from day 13 (day_index 12):")
    for b in blocks:
        bid, dstart, dend, sdate, edate, cnt = b
        print(f" Block {bid}: day_index {dstart}..{dend}  ({sdate} -> {edate})  rows: {cnt:,}")

# Also print total rows covered by first12 + all blocks (should be <= total)
covered = rows_first12 + sum(b[-1] for b in blocks) if 'blocks' in locals() else rows_first12
print(f"\nRows covered by reported windows: {covered:,} (of {n_total:,})")
if covered != n_total:
    print("Note: remaining rows may have unparsable timestamps or fall outside counted day range.")
