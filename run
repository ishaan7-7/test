import streamlit as st
import pandas as pd
import asyncio
import threading
import time
from pathlib import Path
import sys

# --- Path Setup ---
# Add the root directory to sys.path so we can import from telemetry_observer and ingest
CURRENT_DIR = Path(__file__).resolve().parent
ROOT_DIR = CURRENT_DIR.parent
if str(ROOT_DIR) not in sys.path:
    sys.path.append(str(ROOT_DIR))

# Import the Engine from Phase 1
from telemetry_observer.observer_backend import HybridObserver

# ---------------------------------------------------------
# Page Configuration
# ---------------------------------------------------------
st.set_page_config(
    page_title="Telemetry Observer",
    page_icon="üì°",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for Status Indicators
st.markdown("""
<style>
    .status-box {
        padding: 8px;
        border-radius: 5px;
        text-align: center;
        font-weight: bold;
        color: white;
        margin-bottom: 5px;
        font-size: 0.9em;
    }
    .status-up { background-color: #28a745; }
    .status-down { background-color: #dc3545; }
    div[data-testid="stMetricValue"] { font-size: 20px; }
</style>
""", unsafe_allow_html=True)

# ---------------------------------------------------------
# Singleton Pattern: Start Engine in Background
# ---------------------------------------------------------
@st.cache_resource
def get_running_observer():
    """
    Instantiates the HybridObserver and runs its async start() method
    in a dedicated background thread.
    """
    observer = HybridObserver()
    
    def start_loop():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(observer.start())

    # Start the observer in a daemon thread so it doesn't block UI
    t = threading.Thread(target=start_loop, daemon=True)
    t.start()
    
    # Give it a moment to initialize
    time.sleep(1)
    return observer

observer = get_running_observer()

# ---------------------------------------------------------
# Data Fetching
# ---------------------------------------------------------
# Since the observer runs in a thread, we just need to call the sync/async wrapper
# The get_snapshot is async, so we run it in the main streamlit loop
loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)
snapshot = loop.run_until_complete(observer.get_snapshot())

# ---------------------------------------------------------
# SECTION 1: Mission Control (System Health)
# ---------------------------------------------------------
st.title("üì° Telemetry Observer")

# A. Status Bar (Ports)
ports = snapshot.get("system_health", {})
if ports:
    cols = st.columns(len(ports))
    for idx, (service_name, is_up) in enumerate(ports.items()):
        status_class = "status-up" if is_up else "status-down"
        icon = "‚úÖ" if is_up else "‚ùå"
        with cols[idx]:
            st.markdown(
                f'<div class="status-box {status_class}">{icon} {service_name}</div>', 
                unsafe_allow_html=True
            )

st.markdown("---")

# B. Global KPIs
stats = snapshot.get("global_stats", {})

k1, k2, k3, k4 = st.columns(4)
with k1: 
    st.metric("Total Rows Processed", f"{stats.get('total_rows', 0):,}")
with k2: 
    st.metric("Active Vehicles", stats.get("active_vehicles", 0))
with k3: 
    lat = stats.get("avg_latency", 0)
    st.metric("Global Avg Latency", f"{lat} ms", delta_color="inverse")
with k4: 
    dlq = stats.get("dlq_backlog", 0)
    st.metric("DLQ Backlog", dlq, delta_color="inverse")

# ---------------------------------------------------------
# SECTION 2 & 3: Analytics & Leaderboard
# ---------------------------------------------------------
vehicles = snapshot.get("vehicles", [])

if vehicles:
    # Prepare DataFrame
    df = pd.DataFrame(vehicles)
    
    # Create Tabs
    tab1, tab2, tab3 = st.tabs(["üèÜ Leaderboard", "üìä Fleet Analytics", "üîç Live Inspector"])

    # --- Tab 1: Leaderboard ---
    with tab1:
        # We format the dataframe for display
        display_df = df[[
            "vehicle_id", "rows_processed", "rejected_rows", 
            "validation_rate", "avg_latency", "last_seen_sec"
        ]].copy()
        
        st.dataframe(
            display_df,
            column_config={
                "vehicle_id": "Vehicle ID",
                "rows_processed": "Rows",
                "rejected_rows": "Rejected",
                "validation_rate": st.column_config.ProgressColumn(
                    "Quality %",
                    help="Percentage of rows accepted",
                    format="%.1f%%",
                    min_value=0,
                    max_value=100,
                ),
                "avg_latency": st.column_config.NumberColumn(
                    "Latency (ms)",
                    format="%.1f ms"
                ),
                "last_seen_sec": st.column_config.NumberColumn(
                    "Last Seen (s)",
                    format="%.1f s"
                )
            },
            use_container_width=True,
            hide_index=True
        )

    # --- Tab 2: Fleet Analytics (Charts) ---
    with tab2:
        c1, c2 = st.columns(2)
        
        with c1:
            st.subheader("Latency Heatmap")
            # Bar chart of Latency per Vehicle
            st.bar_chart(df.set_index("vehicle_id")["avg_latency"], color="#FFA500")
            
        with c2:
            st.subheader("Quality Distribution")
            # Stacked bar chart of Rows vs Rejected (Proxy for quality volume)
            # We create a simple view of Accepted vs Rejected
            chart_data = df.set_index("vehicle_id")[["rows_processed", "rejected_rows"]]
            chart_data.columns = ["Accepted", "Rejected"]
            st.bar_chart(chart_data, color=["#28a745", "#dc3545"])

    # --- Tab 3: Live Inspector ---
    with tab3:
        # Selector
        v_list = df["vehicle_id"].tolist()
        v_list.sort()
        selected_v = st.selectbox("Select Vehicle to Inspect:", v_list)
        
        if selected_v:
            # Find data for selected vehicle
            v_data = next((item for item in vehicles if item["vehicle_id"] == selected_v), None)
            
            if v_data:
                # Health Card
                hc1, hc2, hc3 = st.columns(3)
                hc1.info(f"**ID:** {v_data['vehicle_id']}")
                hc2.success(f"**Accepted:** {v_data['rows_processed']}")
                if v_data['rejected_rows'] > 0:
                    hc3.error(f"**Rejected:** {v_data['rejected_rows']}")
                else:
                    hc3.success("**Rejected:** 0")

                # JSON Payload
                st.caption("Latest Live Payload (Real-time from Kafka)")
                payload = v_data.get("latest_payload")
                if payload:
                    st.json(payload, expanded=True)
                else:
                    st.warning("No data packet received yet.")
            
else:
    st.info("Waiting for data stream... Start your Replay Service!")

# ---------------------------------------------------------
# Auto-Refresh Logic
# ---------------------------------------------------------
# This keeps the dashboard live
time.sleep(1)
st.rerun()
